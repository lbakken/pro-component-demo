System.register(['./chunk-5603b3cb.system.js', './chunk-17730780.system.js', './chunk-05185aad.system.js'], function (exports) {
    'use strict';
    var registerInstance, createEvent, getIonMode, h, Host, getElement, openURL, createColorClasses, hasShadowDom;
    return {
        setters: [function (module) {
                registerInstance = module.r;
                createEvent = module.d;
                getIonMode = module.f;
                h = module.h;
                Host = module.H;
                getElement = module.c;
            }, function (module) {
                openURL = module.o;
                createColorClasses = module.c;
            }, function (module) {
                hasShadowDom = module.h;
            }],
        execute: function () {
            /**
             * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
             *
             * @slot - Content is placed between the named slots if provided without a slot.
             * @slot icon-only - Should be used on an icon in a button that has no text.
             * @slot start - Content is placed to the left of the button text in LTR, and to the right in RTL.
             * @slot end - Content is placed to the right of the button text in LTR, and to the left in RTL.
             */
            var Button = /** @class */ (function () {
                function Button(hostRef) {
                    var _this = this;
                    registerInstance(this, hostRef);
                    this.inToolbar = false;
                    this.inItem = false;
                    /**
                     * The type of button.
                     */
                    this.buttonType = 'button';
                    /**
                     * If `true`, the user cannot interact with the button.
                     */
                    this.disabled = false;
                    /**
                     * When using a router, it specifies the transition direction when navigating to
                     * another page using `href`.
                     */
                    this.routerDirection = 'forward';
                    /**
                     * If `true`, activates a button with a heavier font weight.
                     */
                    this.strong = false;
                    /**
                     * The type of the button.
                     */
                    this.type = 'button';
                    this.handleClick = function (ev) {
                        if (_this.type === 'button') {
                            openURL(_this.href, ev, _this.routerDirection);
                        }
                        else if (hasShadowDom(_this.el)) {
                            // this button wants to specifically submit a form
                            // climb up the dom to see if we're in a <form>
                            // and if so, then use JS to submit it
                            var form = _this.el.closest('form');
                            if (form) {
                                ev.preventDefault();
                                var fakeButton = document.createElement('button');
                                fakeButton.type = _this.type;
                                fakeButton.style.display = 'none';
                                form.appendChild(fakeButton);
                                fakeButton.click();
                                fakeButton.remove();
                            }
                        }
                    };
                    this.onFocus = function () {
                        _this.ionFocus.emit();
                    };
                    this.onBlur = function () {
                        _this.ionBlur.emit();
                    };
                    this.ionFocus = createEvent(this, "ionFocus", 7);
                    this.ionBlur = createEvent(this, "ionBlur", 7);
                }
                Button.prototype.componentWillLoad = function () {
                    this.inToolbar = !!this.el.closest('ion-buttons');
                    this.inItem = !!this.el.closest('ion-item') || !!this.el.closest('ion-item-divider');
                };
                Object.defineProperty(Button.prototype, "hasIconOnly", {
                    get: function () {
                        return !!this.el.querySelector('ion-icon[slot="icon-only"]');
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Button.prototype, "rippleType", {
                    get: function () {
                        var hasClearFill = this.fill === undefined || this.fill === 'clear';
                        // If the button is in a toolbar, has a clear fill (which is the default)
                        // and only has an icon we use the unbounded "circular" ripple effect
                        if (hasClearFill && this.hasIconOnly && this.inToolbar) {
                            return 'unbounded';
                        }
                        return 'bounded';
                    },
                    enumerable: true,
                    configurable: true
                });
                Button.prototype.render = function () {
                    var _a;
                    var mode = getIonMode(this);
                    var _b = this, buttonType = _b.buttonType, type = _b.type, disabled = _b.disabled, rel = _b.rel, target = _b.target, size = _b.size, href = _b.href, color = _b.color, expand = _b.expand, hasIconOnly = _b.hasIconOnly, shape = _b.shape, strong = _b.strong;
                    var finalSize = size === undefined && this.inItem ? 'small' : size;
                    var TagType = href === undefined ? 'button' : 'a';
                    var attrs = (TagType === 'button')
                        ? { type: type }
                        : {
                            download: this.download,
                            href: href,
                            rel: rel,
                            target: target
                        };
                    var fill = this.fill;
                    if (fill === undefined) {
                        fill = this.inToolbar ? 'clear' : 'solid';
                    }
                    return (h(Host, { onClick: this.handleClick, "aria-disabled": disabled ? 'true' : null, class: Object.assign({}, createColorClasses(color), (_a = {}, _a[mode] = true, _a[buttonType] = true, _a[buttonType + "-" + expand] = expand !== undefined, _a[buttonType + "-" + finalSize] = finalSize !== undefined, _a[buttonType + "-" + shape] = shape !== undefined, _a[buttonType + "-" + fill] = true, _a[buttonType + "-strong"] = strong, _a['button-has-icon-only'] = hasIconOnly, _a['button-disabled'] = disabled, _a['ion-activatable'] = true, _a['ion-focusable'] = true, _a)) }, h(TagType, Object.assign({}, attrs, { class: "button-native", disabled: disabled, onFocus: this.onFocus, onBlur: this.onBlur }), h("span", { class: "button-inner" }, h("slot", { name: "icon-only" }), h("slot", { name: "start" }), h("slot", null), h("slot", { name: "end" })), mode === 'md' && h("ion-ripple-effect", { type: this.rippleType }))));
                };
                Object.defineProperty(Button.prototype, "el", {
                    get: function () { return getElement(this); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Button, "style", {
                    get: function () { return "STYLE_TEXT_PLACEHOLDER:ion-button"; },
                    enumerable: true,
                    configurable: true
                });
                return Button;
            }());
            exports('ion_button', Button);
        }
    };
});
